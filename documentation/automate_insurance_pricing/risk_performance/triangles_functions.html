<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>automate_insurance_pricing.risk_performance.triangles_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>automate_insurance_pricing.risk_performance.triangles_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import seaborn as sns

import chainladder as cl

import matplotlib.pyplot as plt



def add_ibnr(row, ibnr_rates, extraction_year, claims_column_name=&#39;asif_total_capped_cost&#39;, occurrence_date_column_name=&#39;occurrence_date&#39;):
    &#34;&#34;&#34; Adds IBNR to claims costs   
        Arguments --&gt; the dataframe row, the list of ibnr rates per year, the extraction year,   
            the claims amounts and occurrence dates columns names
    &#34;&#34;&#34;
    claim_year = row[occurrence_date_column_name].year

    try:
        rates_index = int(extraction_year - claim_year)
    except:
        rates_index = 0

    return row[claims_column_name] * (1 + ibnr_rates[rates_index]) 


def get_triangle_projections(triangles, average_methods=None, n_periods=None, grain=&#39;OYDY&#39;):
    &#34;&#34;&#34;
        Generates the main kpis such as ultimate loss, ibnr, loss development factors   
        Arguments --&gt; A dictionnary of triangles or a single triangle,   
            the methods to derive the LDF (simple or volume average) defined as a list if there are several ultimate triangles to produce,   
            the number of periods to look at (-1 means all periods by default)   
            the origin/development pattern (&#39;OxDy&#39; with x and y in (Y, M, Q))   
        Returns --&gt; a dictionnary storing the triangles and other kpis   
            the dict keys are &#39;ldf&#39; for loss development factors, &#39;cdf&#39; for the cumulative ones, &#39;fit&#39; to get the fitted model and &#39;full_triangle&#39; to get the full triangle produced

    &#34;&#34;&#34;

    triangles_values = triangles.values() if isinstance(triangles, dict) else [triangles]
    triangles_keys = triangles.keys() if isinstance(triangles, dict) else [1]

    selected_average_methods = [&#39;volume&#39;] * len(triangles_keys) if average_methods is None else \
                                average_methods if isinstance(average_methods, list) else [average_methods]

    selected_n_periods = [-1] * len(triangles_keys) if n_periods is None else \
                        n_periods if isinstance(n_periods, list) else [n_periods]

    # Gets the different types of figures we are studying (asif cost, cost excl LL, count, etc.)
    triangles_names = [triangle.columns[0] for triangle in triangles_values]

    # Builds the triangle transformer with development attributes ; loops through the triangles
    triangles_dev = [cl.Pipeline([(&#39;dev&#39;, cl.Development(average=selected_average_methods[index], n_periods=selected_n_periods[index]))])
                     .fit_transform(triangle.grain(grain)) for index, triangle in enumerate(triangles_values)]

    # Loops through the triangles_dev to derive the ldfs, cdfs and the fit method
    triangles_model = [(triangle_dev.ldf_, triangle_dev.cdf_, cl.Chainladder().fit(triangle_dev)) for triangle_dev in triangles_dev]

    # Loops through the triangles_model to build a dict with the name of the figures (claims cost, count, etc.)
    # as primary key and the main triangle characteristics as second keys
    return {value: {
                    &#39;ldf&#39;: triangles_model[index][0],
                    &#39;cdf&#39;: triangles_model[index][1],
                    &#39;fit&#39;: triangles_model[index][2],
                    &#39;full_triangle&#39;: pd.concat([triangles_model[index][2].full_triangle_.to_frame(), triangles_model[index][2].ibnr_.to_frame()] \
                                               , axis=1).rename(columns={9999: &#39;Ultimates&#39;, value: &#39;IBNR&#39;})
                    }
            for index, value in enumerate(triangles_names)}


def plot_triangles_dev(triangles, columns=None, grain=None, save=True, prefix_name_fig=None, folder=&#39;Charts&#39;):
    &#34;&#34;&#34;
        Plots the development patterns for the desired figures   
        Arguments --&gt; the dictionnary gathering the triangles of different types of figures (amounts, counts, etc.),   
            the kpis we want to plot and the origin/development pattern (&#39;OxDy&#39; with x and y in (Y, M, Q)),   
            a boolean to indicate if the plot has to be saved or not, the prefix name for the saved file, the chart title and the folder where to save the chart   
        Returns --&gt; Nothing. It just displays the graphs
    &#34;&#34;&#34;

    new_columns =  list(triangles.keys()) if columns is None else columns if isinstance(columns, list) == True else [columns]
    prefix_name_fig = prefix_name_fig + &#39;_&#39; if prefix_name_fig is not None else &#39;&#39;

    # Gets the triangles from the dict and derives the cumulative percentage
    if grain is not None:
        percentage_development = [triangles[column].grain(grain).T / triangles[column].grain(grain).T.max() for column in new_columns]
    else:
        percentage_development = [triangles[column].T / triangles[column].T.max() for column in new_columns]

    for index, dev in enumerate(percentage_development):
        column_name = new_columns[index].replace(&#39;asif_&#39;, &#39;&#39;).replace(&#39;_&#39;, &#39; &#39;)
        dev.plot()
        plt.xlabel(&#39;{} Developement in percentage&#39;.format(column_name[0].capitalize() + column_name[1:]))

        if save == True:
            plt.savefig(folder + &#39;/&#39; + prefix_name_fig + column_name + &#39;.png&#39;)


def select_triangles(multi_triangles, all_indexes_total=True, columns=None):
    &#34;&#34;&#34;
        Gets the triangles from a chainladder triangle class depending   
        Arguments --&gt; the chainladder multi triangles class (i.e. a triangle with segmentation level like the figures by guarantee),   
            a boolean indicating if the function must build the total triangle ignoring its index values (i.e. the totals with no data segmentation).   
            Index values are equivalent to a groupby aggregation variable ; so setting all_indexes_total to True is equivalent to undo the aggregation and to get the triangle for the whole portfolio,   
            setting it to False will make you get a triangle for each of the index (e.g. for each guarantee)   
            the columns (amounts, number of claims etc.) to look at,   
        Returns --&gt; a dictionnary of triangles with index_values and columns as keys and triangles as values
    &#34;&#34;&#34;

    triangles = []
    new_columns = multi_triangles.columns if columns is None else [columns] if isinstance(columns, str) == True else columns

    # Gets a triangle for each index of the chainladder multi triangle
    if all_indexes_total == False:
        # Gets all possible combinaisons for the index (this is all the groupby formed by the chainladder triangle)
        triangles_index_values = multi_triangles.index.values

        # Gets the appropriate triangle for the index_value combinaison and the desired column (i.e. figure summed by the chainladder)
        triangles = [[multi_triangles.loc[tuple(index_value)][column] for index_value in triangles_index_values] for column in new_columns]

        # Converts the list into a dict so that it is easier to retrieve it after
        triangles = {tuple(triangle.index.values[0]) + tuple(triangle.columns): triangle for triangles_list in triangles for triangle in triangles_list}

    # Only one total triangle for each column without filtering by any index value
    else:

        # There is no index in the multi triangle, simply retrieves desired figures thanks to the columns names
        if multi_triangles.index.shape[0]  == 1:
            triangles = {column: multi_triangles[column] for column in new_columns}

        # There are indexes in the multi triangle. To get for each column the total amount, ignoring the indexes, a sum must be applied.
        else:
            # Creates the triangle for each column specified in the arguments
            triangles = {column: multi_triangles[column].sum() for column in new_columns}

    return triangles</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="automate_insurance_pricing.risk_performance.triangles_functions.add_ibnr"><code class="name flex">
<span>def <span class="ident">add_ibnr</span></span>(<span>row, ibnr_rates, extraction_year, claims_column_name='asif_total_capped_cost', occurrence_date_column_name='occurrence_date')</span>
</code></dt>
<dd>
<div class="desc"><p>Adds IBNR to claims costs <br>
Arguments &ndash;&gt; the dataframe row, the list of ibnr rates per year, the extraction year, <br>
the claims amounts and occurrence dates columns names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ibnr(row, ibnr_rates, extraction_year, claims_column_name=&#39;asif_total_capped_cost&#39;, occurrence_date_column_name=&#39;occurrence_date&#39;):
    &#34;&#34;&#34; Adds IBNR to claims costs   
        Arguments --&gt; the dataframe row, the list of ibnr rates per year, the extraction year,   
            the claims amounts and occurrence dates columns names
    &#34;&#34;&#34;
    claim_year = row[occurrence_date_column_name].year

    try:
        rates_index = int(extraction_year - claim_year)
    except:
        rates_index = 0

    return row[claims_column_name] * (1 + ibnr_rates[rates_index]) </code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_performance.triangles_functions.get_triangle_projections"><code class="name flex">
<span>def <span class="ident">get_triangle_projections</span></span>(<span>triangles, average_methods=None, n_periods=None, grain='OYDY')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the main kpis such as ultimate loss, ibnr, loss development factors <br>
Arguments &ndash;&gt; A dictionnary of triangles or a single triangle, <br>
the methods to derive the LDF (simple or volume average) defined as a list if there are several ultimate triangles to produce, <br>
the number of periods to look at (-1 means all periods by default) <br>
the origin/development pattern ('OxDy' with x and y in (Y, M, Q)) <br>
Returns &ndash;&gt; a dictionnary storing the triangles and other kpis <br>
the dict keys are 'ldf' for loss development factors, 'cdf' for the cumulative ones, 'fit' to get the fitted model and 'full_triangle' to get the full triangle produced</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_triangle_projections(triangles, average_methods=None, n_periods=None, grain=&#39;OYDY&#39;):
    &#34;&#34;&#34;
        Generates the main kpis such as ultimate loss, ibnr, loss development factors   
        Arguments --&gt; A dictionnary of triangles or a single triangle,   
            the methods to derive the LDF (simple or volume average) defined as a list if there are several ultimate triangles to produce,   
            the number of periods to look at (-1 means all periods by default)   
            the origin/development pattern (&#39;OxDy&#39; with x and y in (Y, M, Q))   
        Returns --&gt; a dictionnary storing the triangles and other kpis   
            the dict keys are &#39;ldf&#39; for loss development factors, &#39;cdf&#39; for the cumulative ones, &#39;fit&#39; to get the fitted model and &#39;full_triangle&#39; to get the full triangle produced

    &#34;&#34;&#34;

    triangles_values = triangles.values() if isinstance(triangles, dict) else [triangles]
    triangles_keys = triangles.keys() if isinstance(triangles, dict) else [1]

    selected_average_methods = [&#39;volume&#39;] * len(triangles_keys) if average_methods is None else \
                                average_methods if isinstance(average_methods, list) else [average_methods]

    selected_n_periods = [-1] * len(triangles_keys) if n_periods is None else \
                        n_periods if isinstance(n_periods, list) else [n_periods]

    # Gets the different types of figures we are studying (asif cost, cost excl LL, count, etc.)
    triangles_names = [triangle.columns[0] for triangle in triangles_values]

    # Builds the triangle transformer with development attributes ; loops through the triangles
    triangles_dev = [cl.Pipeline([(&#39;dev&#39;, cl.Development(average=selected_average_methods[index], n_periods=selected_n_periods[index]))])
                     .fit_transform(triangle.grain(grain)) for index, triangle in enumerate(triangles_values)]

    # Loops through the triangles_dev to derive the ldfs, cdfs and the fit method
    triangles_model = [(triangle_dev.ldf_, triangle_dev.cdf_, cl.Chainladder().fit(triangle_dev)) for triangle_dev in triangles_dev]

    # Loops through the triangles_model to build a dict with the name of the figures (claims cost, count, etc.)
    # as primary key and the main triangle characteristics as second keys
    return {value: {
                    &#39;ldf&#39;: triangles_model[index][0],
                    &#39;cdf&#39;: triangles_model[index][1],
                    &#39;fit&#39;: triangles_model[index][2],
                    &#39;full_triangle&#39;: pd.concat([triangles_model[index][2].full_triangle_.to_frame(), triangles_model[index][2].ibnr_.to_frame()] \
                                               , axis=1).rename(columns={9999: &#39;Ultimates&#39;, value: &#39;IBNR&#39;})
                    }
            for index, value in enumerate(triangles_names)}</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_performance.triangles_functions.plot_triangles_dev"><code class="name flex">
<span>def <span class="ident">plot_triangles_dev</span></span>(<span>triangles, columns=None, grain=None, save=True, prefix_name_fig=None, folder='Charts')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the development patterns for the desired figures <br>
Arguments &ndash;&gt; the dictionnary gathering the triangles of different types of figures (amounts, counts, etc.), <br>
the kpis we want to plot and the origin/development pattern ('OxDy' with x and y in (Y, M, Q)), <br>
a boolean to indicate if the plot has to be saved or not, the prefix name for the saved file, the chart title and the folder where to save the chart <br>
Returns &ndash;&gt; Nothing. It just displays the graphs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_triangles_dev(triangles, columns=None, grain=None, save=True, prefix_name_fig=None, folder=&#39;Charts&#39;):
    &#34;&#34;&#34;
        Plots the development patterns for the desired figures   
        Arguments --&gt; the dictionnary gathering the triangles of different types of figures (amounts, counts, etc.),   
            the kpis we want to plot and the origin/development pattern (&#39;OxDy&#39; with x and y in (Y, M, Q)),   
            a boolean to indicate if the plot has to be saved or not, the prefix name for the saved file, the chart title and the folder where to save the chart   
        Returns --&gt; Nothing. It just displays the graphs
    &#34;&#34;&#34;

    new_columns =  list(triangles.keys()) if columns is None else columns if isinstance(columns, list) == True else [columns]
    prefix_name_fig = prefix_name_fig + &#39;_&#39; if prefix_name_fig is not None else &#39;&#39;

    # Gets the triangles from the dict and derives the cumulative percentage
    if grain is not None:
        percentage_development = [triangles[column].grain(grain).T / triangles[column].grain(grain).T.max() for column in new_columns]
    else:
        percentage_development = [triangles[column].T / triangles[column].T.max() for column in new_columns]

    for index, dev in enumerate(percentage_development):
        column_name = new_columns[index].replace(&#39;asif_&#39;, &#39;&#39;).replace(&#39;_&#39;, &#39; &#39;)
        dev.plot()
        plt.xlabel(&#39;{} Developement in percentage&#39;.format(column_name[0].capitalize() + column_name[1:]))

        if save == True:
            plt.savefig(folder + &#39;/&#39; + prefix_name_fig + column_name + &#39;.png&#39;)</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_performance.triangles_functions.select_triangles"><code class="name flex">
<span>def <span class="ident">select_triangles</span></span>(<span>multi_triangles, all_indexes_total=True, columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the triangles from a chainladder triangle class depending <br>
Arguments &ndash;&gt; the chainladder multi triangles class (i.e. a triangle with segmentation level like the figures by guarantee), <br>
a boolean indicating if the function must build the total triangle ignoring its index values (i.e. the totals with no data segmentation). <br>
Index values are equivalent to a groupby aggregation variable ; so setting all_indexes_total to True is equivalent to undo the aggregation and to get the triangle for the whole portfolio, <br>
setting it to False will make you get a triangle for each of the index (e.g. for each guarantee) <br>
the columns (amounts, number of claims etc.) to look at, <br>
Returns &ndash;&gt; a dictionnary of triangles with index_values and columns as keys and triangles as values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_triangles(multi_triangles, all_indexes_total=True, columns=None):
    &#34;&#34;&#34;
        Gets the triangles from a chainladder triangle class depending   
        Arguments --&gt; the chainladder multi triangles class (i.e. a triangle with segmentation level like the figures by guarantee),   
            a boolean indicating if the function must build the total triangle ignoring its index values (i.e. the totals with no data segmentation).   
            Index values are equivalent to a groupby aggregation variable ; so setting all_indexes_total to True is equivalent to undo the aggregation and to get the triangle for the whole portfolio,   
            setting it to False will make you get a triangle for each of the index (e.g. for each guarantee)   
            the columns (amounts, number of claims etc.) to look at,   
        Returns --&gt; a dictionnary of triangles with index_values and columns as keys and triangles as values
    &#34;&#34;&#34;

    triangles = []
    new_columns = multi_triangles.columns if columns is None else [columns] if isinstance(columns, str) == True else columns

    # Gets a triangle for each index of the chainladder multi triangle
    if all_indexes_total == False:
        # Gets all possible combinaisons for the index (this is all the groupby formed by the chainladder triangle)
        triangles_index_values = multi_triangles.index.values

        # Gets the appropriate triangle for the index_value combinaison and the desired column (i.e. figure summed by the chainladder)
        triangles = [[multi_triangles.loc[tuple(index_value)][column] for index_value in triangles_index_values] for column in new_columns]

        # Converts the list into a dict so that it is easier to retrieve it after
        triangles = {tuple(triangle.index.values[0]) + tuple(triangle.columns): triangle for triangles_list in triangles for triangle in triangles_list}

    # Only one total triangle for each column without filtering by any index value
    else:

        # There is no index in the multi triangle, simply retrieves desired figures thanks to the columns names
        if multi_triangles.index.shape[0]  == 1:
            triangles = {column: multi_triangles[column] for column in new_columns}

        # There are indexes in the multi triangle. To get for each column the total amount, ignoring the indexes, a sum must be applied.
        else:
            # Creates the triangle for each column specified in the arguments
            triangles = {column: multi_triangles[column].sum() for column in new_columns}

    return triangles</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="automate_insurance_pricing.risk_performance" href="index.html">automate_insurance_pricing.risk_performance</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="automate_insurance_pricing.risk_performance.triangles_functions.add_ibnr" href="#automate_insurance_pricing.risk_performance.triangles_functions.add_ibnr">add_ibnr</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_performance.triangles_functions.get_triangle_projections" href="#automate_insurance_pricing.risk_performance.triangles_functions.get_triangle_projections">get_triangle_projections</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_performance.triangles_functions.plot_triangles_dev" href="#automate_insurance_pricing.risk_performance.triangles_functions.plot_triangles_dev">plot_triangles_dev</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_performance.triangles_functions.select_triangles" href="#automate_insurance_pricing.risk_performance.triangles_functions.select_triangles">select_triangles</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>