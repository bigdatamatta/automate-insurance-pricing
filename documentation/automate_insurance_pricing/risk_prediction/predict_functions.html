<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>automate_insurance_pricing.risk_prediction.predict_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>automate_insurance_pricing.risk_prediction.predict_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np

from sklearn.preprocessing import FunctionTransformer

from timeit import default_timer as timer

from automate_insurance_pricing.reports.export_functions import *


def get_glm_rating_factors(df, glm_coefs, num_features_analysis, constant_column_name=&#39;const&#39;, transformer=FunctionTransformer(), export_excel=False, glm_file_path=None):
    &#34;&#34;&#34;
        Gets the GLM rating factor values for all features values   
        Arguments --&gt; the dataframe, the coefs values found by the glm for each feature, the numerical features names, the column name for the constant (reference) obtained by the glm   
            the transformer object which corresponds to the link for a GLM,   
            a boolean indicating if it needs to export the results to excel, and the export file path   
        Returns --&gt; a dict with feature as keys and tuples as values corresponding to the feature modalities and their impacts on the target variable (i.e. the rating factor applied on the feature value)
    &#34;&#34;&#34;

    features_coefs = {}

    for feature in glm_coefs.index:

        if feature != constant_column_name and ((feature in df.columns and len(df[feature].unique()) &gt; 2) or feature not in df.columns):
            glm_coef = glm_coefs[glm_coefs.index==feature][0]
            number_features = feature.count(&#39;:&#39;) + 1
            features = feature.split(&#39;:&#39;)
            original_values = df[features[0].replace(&#39;_scaled&#39;, &#39;&#39;)]

            min_value, max_value = original_values.min(), original_values.max()
            discrete_values = list(range(int(min_value), int(max_value) + 1, int(max_value/100 + 1)))

            if len(features) &gt; 1:

                for selected_feature in features[1:]:

                    if selected_feature in num_features_analysis:
                        original_values = df[selected_feature]
                        new_min_value, new_max_value = original_values.min(), original_values.max()
                        new_discrete_values = list(range(int(new_min_value), int(new_max_value) + 1, int(new_max_value/100 + 1)))

                        min_value *= new_min_value
                        max_value *= new_max_value

                        df_cartesian = (
                            pd.DataFrame(discrete_values).assign(key=1)
                            .merge(pd.DataFrame(new_discrete_values).assign(key=1), on=&#34;key&#34;)
                            .drop(&#34;key&#34;, axis=1)
                        )

                        discrete_values = list(df_cartesian.iloc[:, 0] * df_cartesian.iloc[:, 1])

            diff_from_min_scaled = (discrete_values - min_value) / (max_value - min_value)
            feature_coefs = transformer.inverse_transform(glm_coef * diff_from_min_scaled).tolist()

        else:
            discrete_values = [1]
            feature_coefs = [transformer.inverse_transform(glm_coefs[glm_coefs.index==feature][0])]

        features_coefs[feature] = list(zip(discrete_values, feature_coefs))

        if export_excel == True:
            export_glm_coefs_to_excel(features_coefs, feature, glm_file_path)

    return features_coefs



def print_model_coefs(model_name, results, features, transformer=FunctionTransformer(), sort=True):
    &#34;&#34;&#34; Displays the selected model and its linear predictor expression   
        Arguments --&gt; the model name, its results, the features,   
            the transformer object which corresponds to the link for a GLM,   
            a boolean indicating if coefs must be sorted
    &#34;&#34;&#34;

    print(&#39;Model {}:\n&#39;.format(model_name))

    if &#39;coefs&#39; in results.keys():
        coefs = results[&#39;coefs&#39;]

        if &#39;alpha&#39; in results.keys():
            print(&#34;{0} model Best alpha: {1}\n&#34;.format(model_name, results[&#39;alpha&#39;]))

        print(&#34;{} model picked &#34;.format(model_name) + str(sum(coefs != 0)) + &#34; variables and eliminated the other &#34; +  str(sum(coefs == 0)) + &#34; variables\n&#34;)

        print(&#34;*********************\n&#34;)

        print(&#39;target variable = {}&#39;.format(print_linear_predictor(coefs, names=features, transformer=transformer, sort=sort)))
        
        

def print_linear_predictor(coefs, names=None, transformer=FunctionTransformer(), sort=False):
    &#34;&#34;&#34; Displays the linear predictor expression   
        Arguments --&gt; the coefficients, the features names associated to them, the link function and a boolean indicating if coefs must be sorted
        Returns --&gt; the expression of the target as linear function of the features
    &#34;&#34;&#34;

    if names == None:
        names = [&#34;X%s&#34; % x for x in range(len(coefs))]
    lst = zip(coefs, names)

    if sort == True:
        lst = sorted(lst,  key= lambda x: -transformer.inverse_transform(np.abs(x[0])))

    return &#34; + &#34;.join(&#34;%s * %s&#34; % (round(coef, 5), name)
                                   for coef, name in lst)


def run_model_predictions(model_name, model, X_train, X_test, y_train, y_test, features, transformer=FunctionTransformer()):
    &#34;&#34;&#34; Runs a model   
        Arguments --&gt; the model name, the model, the train and test independent and target variables   
            the transformer object which corresponds to the link for a GLM,   
        Returns --&gt; the results obtained by the model
    &#34;&#34;&#34;

    results = {}

    y_train_transformed = transformer.transform(y_train)
    results[&#39;model_fit&#39;] = model_fit = model.fit(X_train, y_train_transformed)

    y_test_transformed = transformer.transform(y_test)
    results[&#39;score&#39;] = score = round(model_fit.score(X_test, y_test_transformed), 5)

    results[&#39;predictions&#39;] = transformer.inverse_transform(model_fit.predict(X_test))

    if hasattr(model_fit, &#39;coefs&#39;):
        results[&#39;alpha&#39;] = alpha = round(model_fit.alpha_, 5)

    if hasattr(model_fit, &#39;coefs&#39;):
        try:
            results[&#39;coefs&#39;] = pd.Series(model_fit.coef_[0], index = X_train[features].columns)
        except:
            results[&#39;coefs&#39;] = pd.Series(model_fit.coef_, index = X_train[features].columns)

    return results



def run_simple_model(model, X_test, y_test):
    &#34;&#34;&#34;Runs a simple model with default hyperparameters to quickly obtain its score   
        Arguments --&gt; the model, the independant and dependent variable on the test set   
        Returns --&gt; the model score
    &#34;&#34;&#34;

    start_time = timer()
    model.fit(X_test, y_test)
    training_time = timer() - start_time

    model_score = model.score(X_test, y_test)

    print(&#39;The baseline model applied on the test set has a score of {:.4f}.&#39;.format(model_score))
    print(&#39;The baseline model needs {:.4f} seconds&#39;.format(training_time))

    return model_score</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="automate_insurance_pricing.risk_prediction.predict_functions.get_glm_rating_factors"><code class="name flex">
<span>def <span class="ident">get_glm_rating_factors</span></span>(<span>df, glm_coefs, num_features_analysis, constant_column_name='const', transformer=FunctionTransformer(), export_excel=False, glm_file_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the GLM rating factor values for all features values <br>
Arguments &ndash;&gt; the dataframe, the coefs values found by the glm for each feature, the numerical features names, the column name for the constant (reference) obtained by the glm <br>
the transformer object which corresponds to the link for a GLM, <br>
a boolean indicating if it needs to export the results to excel, and the export file path <br>
Returns &ndash;&gt; a dict with feature as keys and tuples as values corresponding to the feature modalities and their impacts on the target variable (i.e. the rating factor applied on the feature value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_glm_rating_factors(df, glm_coefs, num_features_analysis, constant_column_name=&#39;const&#39;, transformer=FunctionTransformer(), export_excel=False, glm_file_path=None):
    &#34;&#34;&#34;
        Gets the GLM rating factor values for all features values   
        Arguments --&gt; the dataframe, the coefs values found by the glm for each feature, the numerical features names, the column name for the constant (reference) obtained by the glm   
            the transformer object which corresponds to the link for a GLM,   
            a boolean indicating if it needs to export the results to excel, and the export file path   
        Returns --&gt; a dict with feature as keys and tuples as values corresponding to the feature modalities and their impacts on the target variable (i.e. the rating factor applied on the feature value)
    &#34;&#34;&#34;

    features_coefs = {}

    for feature in glm_coefs.index:

        if feature != constant_column_name and ((feature in df.columns and len(df[feature].unique()) &gt; 2) or feature not in df.columns):
            glm_coef = glm_coefs[glm_coefs.index==feature][0]
            number_features = feature.count(&#39;:&#39;) + 1
            features = feature.split(&#39;:&#39;)
            original_values = df[features[0].replace(&#39;_scaled&#39;, &#39;&#39;)]

            min_value, max_value = original_values.min(), original_values.max()
            discrete_values = list(range(int(min_value), int(max_value) + 1, int(max_value/100 + 1)))

            if len(features) &gt; 1:

                for selected_feature in features[1:]:

                    if selected_feature in num_features_analysis:
                        original_values = df[selected_feature]
                        new_min_value, new_max_value = original_values.min(), original_values.max()
                        new_discrete_values = list(range(int(new_min_value), int(new_max_value) + 1, int(new_max_value/100 + 1)))

                        min_value *= new_min_value
                        max_value *= new_max_value

                        df_cartesian = (
                            pd.DataFrame(discrete_values).assign(key=1)
                            .merge(pd.DataFrame(new_discrete_values).assign(key=1), on=&#34;key&#34;)
                            .drop(&#34;key&#34;, axis=1)
                        )

                        discrete_values = list(df_cartesian.iloc[:, 0] * df_cartesian.iloc[:, 1])

            diff_from_min_scaled = (discrete_values - min_value) / (max_value - min_value)
            feature_coefs = transformer.inverse_transform(glm_coef * diff_from_min_scaled).tolist()

        else:
            discrete_values = [1]
            feature_coefs = [transformer.inverse_transform(glm_coefs[glm_coefs.index==feature][0])]

        features_coefs[feature] = list(zip(discrete_values, feature_coefs))

        if export_excel == True:
            export_glm_coefs_to_excel(features_coefs, feature, glm_file_path)

    return features_coefs</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_prediction.predict_functions.print_linear_predictor"><code class="name flex">
<span>def <span class="ident">print_linear_predictor</span></span>(<span>coefs, names=None, transformer=FunctionTransformer(), sort=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the linear predictor expression <br>
Arguments &ndash;&gt; the coefficients, the features names associated to them, the link function and a boolean indicating if coefs must be sorted
Returns &ndash;&gt; the expression of the target as linear function of the features</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_linear_predictor(coefs, names=None, transformer=FunctionTransformer(), sort=False):
    &#34;&#34;&#34; Displays the linear predictor expression   
        Arguments --&gt; the coefficients, the features names associated to them, the link function and a boolean indicating if coefs must be sorted
        Returns --&gt; the expression of the target as linear function of the features
    &#34;&#34;&#34;

    if names == None:
        names = [&#34;X%s&#34; % x for x in range(len(coefs))]
    lst = zip(coefs, names)

    if sort == True:
        lst = sorted(lst,  key= lambda x: -transformer.inverse_transform(np.abs(x[0])))

    return &#34; + &#34;.join(&#34;%s * %s&#34; % (round(coef, 5), name)
                                   for coef, name in lst)</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_prediction.predict_functions.print_model_coefs"><code class="name flex">
<span>def <span class="ident">print_model_coefs</span></span>(<span>model_name, results, features, transformer=FunctionTransformer(), sort=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the selected model and its linear predictor expression <br>
Arguments &ndash;&gt; the model name, its results, the features, <br>
the transformer object which corresponds to the link for a GLM, <br>
a boolean indicating if coefs must be sorted</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_model_coefs(model_name, results, features, transformer=FunctionTransformer(), sort=True):
    &#34;&#34;&#34; Displays the selected model and its linear predictor expression   
        Arguments --&gt; the model name, its results, the features,   
            the transformer object which corresponds to the link for a GLM,   
            a boolean indicating if coefs must be sorted
    &#34;&#34;&#34;

    print(&#39;Model {}:\n&#39;.format(model_name))

    if &#39;coefs&#39; in results.keys():
        coefs = results[&#39;coefs&#39;]

        if &#39;alpha&#39; in results.keys():
            print(&#34;{0} model Best alpha: {1}\n&#34;.format(model_name, results[&#39;alpha&#39;]))

        print(&#34;{} model picked &#34;.format(model_name) + str(sum(coefs != 0)) + &#34; variables and eliminated the other &#34; +  str(sum(coefs == 0)) + &#34; variables\n&#34;)

        print(&#34;*********************\n&#34;)

        print(&#39;target variable = {}&#39;.format(print_linear_predictor(coefs, names=features, transformer=transformer, sort=sort)))</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_prediction.predict_functions.run_model_predictions"><code class="name flex">
<span>def <span class="ident">run_model_predictions</span></span>(<span>model_name, model, X_train, X_test, y_train, y_test, features, transformer=FunctionTransformer())</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a model <br>
Arguments &ndash;&gt; the model name, the model, the train and test independent and target variables <br>
the transformer object which corresponds to the link for a GLM, <br>
Returns &ndash;&gt; the results obtained by the model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_model_predictions(model_name, model, X_train, X_test, y_train, y_test, features, transformer=FunctionTransformer()):
    &#34;&#34;&#34; Runs a model   
        Arguments --&gt; the model name, the model, the train and test independent and target variables   
            the transformer object which corresponds to the link for a GLM,   
        Returns --&gt; the results obtained by the model
    &#34;&#34;&#34;

    results = {}

    y_train_transformed = transformer.transform(y_train)
    results[&#39;model_fit&#39;] = model_fit = model.fit(X_train, y_train_transformed)

    y_test_transformed = transformer.transform(y_test)
    results[&#39;score&#39;] = score = round(model_fit.score(X_test, y_test_transformed), 5)

    results[&#39;predictions&#39;] = transformer.inverse_transform(model_fit.predict(X_test))

    if hasattr(model_fit, &#39;coefs&#39;):
        results[&#39;alpha&#39;] = alpha = round(model_fit.alpha_, 5)

    if hasattr(model_fit, &#39;coefs&#39;):
        try:
            results[&#39;coefs&#39;] = pd.Series(model_fit.coef_[0], index = X_train[features].columns)
        except:
            results[&#39;coefs&#39;] = pd.Series(model_fit.coef_, index = X_train[features].columns)

    return results</code></pre>
</details>
</dd>
<dt id="automate_insurance_pricing.risk_prediction.predict_functions.run_simple_model"><code class="name flex">
<span>def <span class="ident">run_simple_model</span></span>(<span>model, X_test, y_test)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a simple model with default hyperparameters to quickly obtain its score <br>
Arguments &ndash;&gt; the model, the independant and dependent variable on the test set <br>
Returns &ndash;&gt; the model score</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_simple_model(model, X_test, y_test):
    &#34;&#34;&#34;Runs a simple model with default hyperparameters to quickly obtain its score   
        Arguments --&gt; the model, the independant and dependent variable on the test set   
        Returns --&gt; the model score
    &#34;&#34;&#34;

    start_time = timer()
    model.fit(X_test, y_test)
    training_time = timer() - start_time

    model_score = model.score(X_test, y_test)

    print(&#39;The baseline model applied on the test set has a score of {:.4f}.&#39;.format(model_score))
    print(&#39;The baseline model needs {:.4f} seconds&#39;.format(training_time))

    return model_score</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="automate_insurance_pricing.risk_prediction" href="index.html">automate_insurance_pricing.risk_prediction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="automate_insurance_pricing.risk_prediction.predict_functions.get_glm_rating_factors" href="#automate_insurance_pricing.risk_prediction.predict_functions.get_glm_rating_factors">get_glm_rating_factors</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_prediction.predict_functions.print_linear_predictor" href="#automate_insurance_pricing.risk_prediction.predict_functions.print_linear_predictor">print_linear_predictor</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_prediction.predict_functions.print_model_coefs" href="#automate_insurance_pricing.risk_prediction.predict_functions.print_model_coefs">print_model_coefs</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_prediction.predict_functions.run_model_predictions" href="#automate_insurance_pricing.risk_prediction.predict_functions.run_model_predictions">run_model_predictions</a></code></li>
<li><code><a title="automate_insurance_pricing.risk_prediction.predict_functions.run_simple_model" href="#automate_insurance_pricing.risk_prediction.predict_functions.run_simple_model">run_simple_model</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>